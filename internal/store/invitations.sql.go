// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invitations.sql

package store

import (
	"context"
	"database/sql"
)

const countRecentInvitationsByEmail = `-- name: CountRecentInvitationsByEmail :one
SELECT COUNT(*) FROM invitations
WHERE email = ?
  AND created_at > datetime('now', '-1 hour')
`

func (q *Queries) CountRecentInvitationsByEmail(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRecentInvitationsByEmail, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO invitations (token, email, invited_by, expires_at)
VALUES (?, ?, ?, ?)
RETURNING token, email, invited_by, created_at, expires_at
`

type CreateInvitationParams struct {
	Token     string
	Email     string
	InvitedBy int64
	ExpiresAt string
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (Invitation, error) {
	row := q.db.QueryRowContext(ctx, createInvitation,
		arg.Token,
		arg.Email,
		arg.InvitedBy,
		arg.ExpiresAt,
	)
	var i Invitation
	err := row.Scan(
		&i.Token,
		&i.Email,
		&i.InvitedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const deleteExpiredInvitations = `-- name: DeleteExpiredInvitations :execresult
DELETE FROM invitations WHERE expires_at < datetime('now')
`

func (q *Queries) DeleteExpiredInvitations(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteExpiredInvitations)
}

const deleteInvitation = `-- name: DeleteInvitation :exec
DELETE FROM invitations WHERE token = ?
`

func (q *Queries) DeleteInvitation(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteInvitation, token)
	return err
}

const getInvitationByEmail = `-- name: GetInvitationByEmail :one
SELECT token, email, invited_by, created_at, expires_at FROM invitations
WHERE email = ?
  AND expires_at > datetime('now')
`

func (q *Queries) GetInvitationByEmail(ctx context.Context, email string) (Invitation, error) {
	row := q.db.QueryRowContext(ctx, getInvitationByEmail, email)
	var i Invitation
	err := row.Scan(
		&i.Token,
		&i.Email,
		&i.InvitedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getInvitationByToken = `-- name: GetInvitationByToken :one
SELECT token, email, invited_by, created_at, expires_at FROM invitations
WHERE token = ?
  AND expires_at > datetime('now')
`

func (q *Queries) GetInvitationByToken(ctx context.Context, token string) (Invitation, error) {
	row := q.db.QueryRowContext(ctx, getInvitationByToken, token)
	var i Invitation
	err := row.Scan(
		&i.Token,
		&i.Email,
		&i.InvitedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}
